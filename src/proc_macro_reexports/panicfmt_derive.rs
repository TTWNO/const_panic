
/// Derives the [`PanicFmt`](trait@crate::PanicFmt) trait.
///
/// This requires the `"derive"` feature.
///
/// You can also use [`impl_panicfmt`] as an alternative that requires less time to compile 
/// from scratch, but is more verbose.
/// 
/// # Limitations
/// 
/// Types can only have lifetime or integer const parameters,
/// type parameters aren't supported.
/// 
/// ### Const parameters
/// 
/// The value of [`PanicFmt::PV_COUNT`] of fields must not depend on
/// the value of const parameters.
/// <br>Note that arrays have a `PV_COUNT` of `1` for all lengths.
/// 
/// # Attributes
/// 
/// ### Container attributes
/// 
/// Attributes used above the type definition.
/// 
/// `#[pfmt(crate = foo::bar)]`([example](#crate-example)): <br>
/// Replaces the path to `const_panic` with `foo::bar`
/// 
/// `#[pfmt(debug_print)]`: <br>
/// For diagnostics, causes the derive macro to panic with the code generated by it.
/// 
/// # Examples
/// 
/// ### Basic struct
/// 
/// ```rust
/// use const_panic::{ArrayString, FmtArg, PanicFmt};
///
/// let foo = Foo { x: 3, y: &[3, 5, 8] };
/// assert_eq!(
///     ArrayString::<100>::from_panicvals(&foo.to_panicvals(FmtArg::DEBUG)).unwrap(),
///     "Foo { x: 3, y: [3, 5, 8] }",
/// );
///
/// #[derive(PanicFmt)]
/// struct Foo<'a> {
///     x: u32,
///     y: &'a [u8],
/// }
///
/// ```
/// 
/// ### Basic enum
/// 
/// ```rust
/// use const_panic::{ArrayString, FmtArg, PanicFmt};
///
/// let bar = Foo::Bar;
/// assert_eq!(
///     ArrayString::<100>::from_panicvals(&bar.to_panicvals(FmtArg::DEBUG)).unwrap(),
///     "Bar",
/// );
///
/// let baz = Foo::Baz("hello", true);
/// assert_eq!(
///     ArrayString::<100>::from_panicvals(&baz.to_panicvals(FmtArg::DEBUG)).unwrap(),
///     "Baz(\"hello\", true)",
/// );
///
/// #[derive(PanicFmt)]
/// enum Foo {
///     Bar,
///     Baz(&'static str, bool),
/// }
///
/// ```
/// 
/// ### Const-generic struct
/// 
/// Integer const parameters are supported, [with some limitations](#const-parameters).
/// 
/// ```rust
/// use const_panic::{ArrayString, FmtArg, PanicFmt};
///
/// let empty = Foo([]);
/// assert_eq!(
///     ArrayString::<100>::from_panicvals(&empty.to_panicvals(FmtArg::DEBUG)).unwrap(),
///     "Foo([])",
/// );
///
/// let three = Foo([3, 5, 8]);
/// assert_eq!(
///     ArrayString::<100>::from_panicvals(&three.to_panicvals(FmtArg::DEBUG)).unwrap(),
///     "Foo([3, 5, 8])",
/// );
///
/// #[derive(PanicFmt)]
/// struct Foo<const LEN: usize>([u8; LEN]);
///
/// ```
/// 
/// 
/// <a id = "crate-example"></a>
/// ### Crate renaming
/// 
/// This example demonstrates how the `const_panic` crate can be renamed,
/// passing the new name to the derive macro.
/// 
/// ```rust
/// # extern crate const_panic as cpanic;
/// # extern crate std as const_panic;
/// #
/// use cpanic::{ArrayString, FmtArg, PanicFmt};;
/// 
/// let foo = Foo(Some(13));
/// assert_eq!(
///     ArrayString::<100>::from_panicvals(&foo.to_panicvals(FmtArg::DEBUG)).unwrap(),
///     "Foo(Some(13))",
/// );
///
/// #[derive(PanicFmt)]
/// #[pfmt(crate = cpanic)]
/// struct Foo(Option<u32>);
/// ```
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
#[cfg_attr(feature = "docsrs", doc(cfg(feature = "derive")))]
pub use const_panic_proc_macros::PanicFmt;
